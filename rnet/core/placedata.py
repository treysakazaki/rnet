from dataclasses import dataclass
from typing import Callable, Generator, Union
import pandas as pd

try:
    from qgis.core import QgsSingleSymbolRenderer, QgsFeature, QgsGeometry
except:
    pass

from rnet.core.crs import CRS
from rnet.core.element import Element
from rnet.core.field import Field
from rnet.core.layer import Layer, GpkgData
from rnet.utils import abspath, single_marker_renderer, point_geometry


__all__ = ['PlaceData', 'PlaceLayer']


@dataclass
class Place(Element):
    
    id: int
    name: str
    x: float
    y: float
    
    def geometry(self) -> QgsGeometry:
        '''
        Returns the place geometry.
        
        Returns
        -------
        :class:`qgis.core.QgsGeometry`
        '''
        return point_geometry(self.x, self.y)


@dataclass
class PlaceData:
    '''
    Class for representing place data.
    
    Parameters
    ----------
    source : str
        Path to CSV file.
    crs : int
        EPSG code of CRS in which coordinates are represented.
    '''
    
    source: str
    crs: Union[int, CRS]
    layer: Layer = None
    
    def __post_init__(self):
        if type(self.crs) is int:
            self.crs = CRS(self.crs)
        elif isinstance(self.crs, CRS):
            pass
        else:
            raise TypeError("arg 'crs' expected 'str' or 'CRS'")
        self.df = pd.read_csv(abspath(self.source), index_col=0)
    
    def generate(self, report: Callable[[float], None] = lambda x: None
                 ) -> Generator[QgsFeature, None, None]:
        '''
        Yields place features.
        
        Parameters
        ----------
        report : Callable[[float], None], optional
            Function for reporting generator progress.
        
        Yields
        ------
        :class:`qgis.core.QgsFeature`
        '''
        N = len(self.df)
        for i, place in enumerate(self.places(), 1):
            report(i/N*100)
            yield place.feature(i)
    
    def places(self):
        '''
        Yields places in the data set.
        
        Yields
        ------
        :class:`Place`
        '''
        for id, row in self.df.iterrows():
            yield Place(id, *list(row))
    
    def render(self, groupname: str = '', index: int = 0, **kwargs):
        '''
        Renders place features. Existing features are overwritten.
        
        Parameters
        ----------
        groupname : :obj:`str`, optional
            Name of group to which the new layer is inserted. The default is
            ''.
        index : :obj:`int`, optional
            Index within the group to which the layer is inserted. The default
            is 0.
        
        Keyword arguments
        -----------------
        **kwargs : :obj:`dict`, optional
            Keyword arguments that are used to define the renderer settings.
        
        See also
        --------
        :meth:`PlaceLayer.renderer`
            Returns renderer for the place layer.
        '''
        if self.layer is None:
            self.layer = PlaceLayer.create(self.crs.epsg)
            self.layer.render(**kwargs)
        self.layer.populate(self.generate)
        if len(kwargs) > 0:
            self.layer.render(**kwargs)
        self.layer.add(groupname, index)
    
    def transform(self, dst: int) -> None:
        '''
        Transforms :math:`(x, y)` coordinates stored in the ``df`` attribute
        to a new CRS.
        
        Parameters
        ----------
        dst : int
            EPSG code of destination CRS.
        
        Raises
        ------
        EPSGError
            If the EPSG code of the destination CRS is invalid.
        '''
        if dst == self.crs.epsg:
            pass
        else:
            coords = self.crs.transform(self.df[['x', 'y']].to_numpy(), dst)
            self.df['x'] = coords[:,0]
            self.df['y'] = coords[:,1]
            self.crs = CRS(dst)
            self.layer = None
    
    def to_gpkg(self, gpkg: Union[str, GpkgData], layername: str = 'places'
                ) -> None:
        '''
        Saves place features to a GPKG layer. If there exists a
        :class:`VertexLayer` associated with the instance, then the contents
        of the layer are saved. Otherwise, features generated by the
        :meth:`generate` method are saved.
        
        Parameters
        ----------
        gpkg : :class:`GpkgData` or str
            :class:`GpkgData` object or path specifying the GPKG to which
            vertices will be saved.
        layername : str, optional
            Name of the GPKG layer to which vertices are saved. The default
            is 'vertices'.
        '''
        if type(gpkg) is str:
            gpkg = GpkgData(gpkg)
        elif isinstance(gpkg, GpkgData):
            pass
        else:
            raise TypeError("expected 'str' or 'GpkgData' for argument 'gpkg'")
        
        if self.layer is None:
            gpkg.write_features(layername, self.generate, self.crs,
                                PlaceLayer.fields, 'point')
        else:
            self.layer.save(gpkg, layername)


class PlaceLayer(Layer):
    
    @classmethod
    def create(self, crs: int, layername: str = 'places') -> 'PlaceLayer':
        '''
        Instantiates :class:`PlaceLayer`.
        
        Parameters
        ----------
        crs : int
            EPSG code of layer CRS.
        layername : str
            Layer name. The default is 'places'.
        
        Returns
        -------
        :class:`PlaceLayer`
        '''
        fields = [Field('id', 'int'), Field('name', 'str'),
                  Field('x', 'float'), Field('y', 'float')]
        return super().create('point', crs, layername, fields)
    
    @staticmethod
    def renderer(**kwargs) -> QgsSingleSymbolRenderer:
        kwargs.setdefault('color', (168, 50, 72))
        kwargs.setdefault('size', 4.0)
        return single_marker_renderer(**kwargs)
